//
// Copyright (c) 2021 Red Hat, Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package controllers

import (
	"context"
	"strings"
	"testing"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/utils/pointer"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	"github.com/google/go-cmp/cmp"
	api "github.com/redhat-appstudio/service-provider-integration-operator/api/v1beta1"
	"github.com/redhat-appstudio/service-provider-integration-operator/pkg/spi-shared/config"
	"github.com/stretchr/testify/assert"
	corev1 "k8s.io/api/core/v1"
)

func TestValidateServiceProviderUrl(t *testing.T) {
	assert.ErrorIs(t, validateServiceProviderUrl("https://foo."), invalidServiceProviderHostError)
	assert.ErrorIs(t, validateServiceProviderUrl("https://Ca$$h.com"), invalidServiceProviderHostError)

	assert.ErrorContains(t, validateServiceProviderUrl("://invalid"), "not parsable")
	assert.ErrorContains(t, validateServiceProviderUrl("https://rick:mory"), "not parsable")

	assert.NoError(t, validateServiceProviderUrl(config.ServiceProviderTypeGitHub.DefaultBaseUrl))
	assert.NoError(t, validateServiceProviderUrl(config.ServiceProviderTypeQuay.DefaultBaseUrl))
	assert.NoError(t, validateServiceProviderUrl("http://random.ogre"))
}

func TestServiceAccountSecretComparator(t *testing.T) {
	cases := []struct {
		name  string
		equal bool
		a     *corev1.Secret
		b     *corev1.Secret
	}{
		{
			name:  "empty_secrets",
			equal: true,
			a:     &corev1.Secret{},
			b:     &corev1.Secret{},
		},
		{
			name:  "labels_ignored",
			equal: true,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{"a": "b"},
				},
			},
		},
		{
			name:  "annotations_ignored",
			equal: true,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Annotations: map[string]string{"a": "b"},
				},
			},
		},
		{
			name:  "autogenerated_data_fields_ignored",
			equal: true,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				Data: map[string][]byte{
					"ca.crt":    []byte("cert"),
					"namespace": []byte("ns"),
					"token":     []byte("token"),
				},
			},
		},
		{
			name:  "immutable_not_ignored",
			equal: false,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				Immutable: pointer.Bool(false),
			},
		},
		{
			name:  "other_data_fields_not_ignored",
			equal: false,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				Data: map[string][]byte{
					"extra": []byte("value"),
				},
			},
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			res := cmp.Equal(*c.a, *c.b, serviceAccountSecretDiffOpts)

			if c.equal {
				assert.True(t, res, cmp.Diff(*c.a, *c.b, serviceAccountSecretDiffOpts))
			} else {
				assert.False(t, res, cmp.Diff(*c.a, *c.b, serviceAccountSecretDiffOpts))
			}
		})
	}
}

func TestEnsureServiceAccount(t *testing.T) {
	scheme := runtime.NewScheme()
	assert.NoError(t, corev1.AddToScheme(scheme))

	clBld := fake.NewClientBuilder().WithScheme(scheme)

	r := SPIAccessTokenBindingReconciler{
		Scheme: scheme,
	}

	binding := &api.SPIAccessTokenBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "binding",
			Namespace: "default",
		},
		Spec: api.SPIAccessTokenBindingSpec{
			ServiceAccount: api.ServiceAccountSpec{
				Labels: map[string]string{
					"a": "b",
					"c": "d",
				},
				Annotations: map[string]string{
					"a": "b",
					"c": "d",
				},
			},
		},
	}

	t.Run("with SA", func(t *testing.T) {
		cl := clBld.WithObjects(
			&corev1.ServiceAccount{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "sa",
					Namespace: "default",
					Labels: map[string]string{
						"a": "c",
						"e": "f",
					},
					Annotations: map[string]string{
						"a": "c",
						"e": "f",
					},
				},
			},
		).Build()

		r.Client = cl

		binding.Spec.ServiceAccount.Name = "sa"

		sa, err := r.ensureServiceAccount(context.TODO(), binding)
		assert.NoError(t, err)

		assert.Len(t, sa.Labels, 4)
		assert.Equal(t, sa.Labels["a"], "b")
		assert.Equal(t, sa.Labels["c"], "d")
		assert.Equal(t, sa.Labels["e"], "f")
		assert.Equal(t, sa.Labels[SPIAccessTokenBindingLinkLabel], binding.Name)

		assert.Len(t, sa.Annotations, 3)
		assert.Equal(t, sa.Annotations["a"], "b")
		assert.Equal(t, sa.Annotations["c"], "d")
		assert.Equal(t, sa.Annotations["e"], "f")

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), storedSA))
		assert.Equal(t, sa.Name, storedSA.Name)
		assert.Equal(t, sa.Labels, storedSA.Labels)
		assert.Equal(t, sa.Annotations, storedSA.Annotations)
	})

	t.Run("no SA", func(t *testing.T) {
		cl := clBld.Build()
		r.Client = cl

		binding.Spec.ServiceAccount.GenerateName = "sa"

		sa, err := r.ensureServiceAccount(context.TODO(), binding)
		assert.NoError(t, err)

		assert.True(t, strings.HasPrefix(sa.Name, "sa"))
		assert.Len(t, sa.Labels, 4)
		assert.Equal(t, sa.Labels["a"], "b")
		assert.Equal(t, sa.Labels["c"], "d")
		assert.Equal(t, sa.Labels["e"], "f")
		assert.Equal(t, sa.Labels[SPIAccessTokenBindingLinkLabel], binding.Name)

		assert.Len(t, sa.Annotations, 3)
		assert.Equal(t, sa.Annotations["a"], "b")
		assert.Equal(t, sa.Annotations["c"], "d")
		assert.Equal(t, sa.Annotations["e"], "f")

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), storedSA))
		assert.Equal(t, sa.Name, storedSA.Name)
		assert.Equal(t, sa.Labels, storedSA.Labels)
		assert.Equal(t, sa.Annotations, storedSA.Annotations)
	})
}

func TestLinkSecretToServiceAccount(t *testing.T) {
	scheme := runtime.NewScheme()
	assert.NoError(t, corev1.AddToScheme(scheme))

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "secret",
			Namespace: "default",
		},
	}

	sa := &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "sa",
			Namespace: "default",
		},
	}

	cl := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(secret, sa).
		Build()

	r := SPIAccessTokenBindingReconciler{
		Scheme: scheme,
		Client: cl,
	}

	t.Run("link as secret", func(t *testing.T) {
		assert.NoError(t, r.linkSecretToServiceAccount(context.TODO(), api.SecretLinkTypeSecret, secret, sa))

		assert.Len(t, sa.Secrets, 1)
		assert.Equal(t, sa.Secrets[0].Name, secret.Name)

		loadedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), loadedSA))

		assert.Len(t, loadedSA.Secrets, 1)
		assert.Equal(t, loadedSA.Secrets[0].Name, secret.Name)
	})

	t.Run("link as image pull secret", func(t *testing.T) {
		assert.NoError(t, r.linkSecretToServiceAccount(context.TODO(), api.SecretLinkTypeImagePullSecret, secret, sa))

		assert.Len(t, sa.ImagePullSecrets, 1)
		assert.Equal(t, sa.ImagePullSecrets[0].Name, secret.Name)

		loadedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), loadedSA))

		assert.Len(t, loadedSA.ImagePullSecrets, 1)
		assert.Equal(t, loadedSA.ImagePullSecrets[0].Name, secret.Name)
	})
}

func TestUnlinkSecretFromServiceAccount(t *testing.T) {
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "secret",
			Namespace: "default",
		},
	}

	t.Run("removes only referenced secrets", func(t *testing.T) {
		sa := &corev1.ServiceAccount{
			Secrets: []corev1.ObjectReference{
				{
					Name: "another",
				},
				{
					Name: "secret",
				},
			},
			ImagePullSecrets: []corev1.LocalObjectReference{
				{
					Name: "another",
				},
				{
					Name: "secret",
				},
			},
		}

		changed := unlinkSecretFromServiceAccount(secret, sa)

		assert.True(t, changed)
		assert.Len(t, sa.Secrets, 1)
		assert.Len(t, sa.ImagePullSecrets, 1)

		assert.Equal(t, sa.Secrets[0].Name, "another")
		assert.Equal(t, sa.ImagePullSecrets[0].Name, "another")
	})

	t.Run("doesn't fail if not referenced", func(t *testing.T) {
		sa := &corev1.ServiceAccount{
			Secrets: []corev1.ObjectReference{
				{
					Name: "another",
				},
			},
			ImagePullSecrets: []corev1.LocalObjectReference{
				{
					Name: "another",
				},
			},
		}

		changed := unlinkSecretFromServiceAccount(secret, sa)

		assert.False(t, changed)
		assert.Len(t, sa.Secrets, 1)
		assert.Len(t, sa.ImagePullSecrets, 1)

		assert.Equal(t, sa.Secrets[0].Name, "another")
		assert.Equal(t, sa.ImagePullSecrets[0].Name, "another")
	})

	t.Run("doesn't fail on empty", func(t *testing.T) {
		sa := &corev1.ServiceAccount{}

		changed := unlinkSecretFromServiceAccount(secret, sa)

		assert.False(t, changed)
		assert.Len(t, sa.Secrets, 0)
		assert.Len(t, sa.ImagePullSecrets, 0)
	})
}
