//
// Copyright (c) 2021 Red Hat, Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bindings

import (
	"context"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	api "github.com/redhat-appstudio/service-provider-integration-operator/api/v1beta1"
	"github.com/stretchr/testify/assert"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/utils/pointer"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestServiceAccountSecretComparator(t *testing.T) {
	cases := []struct {
		name  string
		equal bool
		a     *corev1.Secret
		b     *corev1.Secret
	}{
		{
			name:  "empty_secrets",
			equal: true,
			a:     &corev1.Secret{},
			b:     &corev1.Secret{},
		},
		{
			name:  "labels_ignored",
			equal: true,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{"a": "b"},
				},
			},
		},
		{
			name:  "annotations_ignored",
			equal: true,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Annotations: map[string]string{"a": "b"},
				},
			},
		},
		{
			name:  "autogenerated_data_fields_ignored",
			equal: true,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				Data: map[string][]byte{
					"ca.crt":    []byte("cert"),
					"namespace": []byte("ns"),
					"token":     []byte("token"),
				},
			},
		},
		{
			name:  "immutable_not_ignored",
			equal: false,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				Immutable: pointer.Bool(false),
			},
		},
		{
			name:  "other_data_fields_not_ignored",
			equal: false,
			a:     &corev1.Secret{},
			b: &corev1.Secret{
				Data: map[string][]byte{
					"extra": []byte("value"),
				},
			},
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			res := cmp.Equal(*c.a, *c.b, serviceAccountSecretDiffOpts)

			if c.equal {
				assert.True(t, res, cmp.Diff(*c.a, *c.b, serviceAccountSecretDiffOpts))
			} else {
				assert.False(t, res, cmp.Diff(*c.a, *c.b, serviceAccountSecretDiffOpts))
			}
		})
	}
}

func TestServiceAccountSync(t *testing.T) {
	scheme := runtime.NewScheme()
	assert.NoError(t, corev1.AddToScheme(scheme))

	clBld := func() *fake.ClientBuilder {
		return fake.NewClientBuilder().WithScheme(scheme)
	}

	binding := &api.SPIAccessTokenBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "binding",
			Namespace: "default",
		},
	}

	h := serviceAccountHandler{
		Binding: binding,
	}

	t.Run("with SA", func(t *testing.T) {
		cl := clBld().WithObjects(
			&corev1.ServiceAccount{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "sa",
					Namespace: "default",
					Labels: map[string]string{
						"a": "b",
						"c": "d",
					},
					Annotations: map[string]string{
						"a": "b",
						"c": "d",
					},
				},
			},
		).Build()

		h.Client = cl

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Reference: corev1.LocalObjectReference{
						Name: "sa",
					},
				},
			},
		}

		sas, _, err := h.Sync(context.TODO())
		assert.NoError(t, err)

		assert.Len(t, sas, 1)
		sa := sas[0]
		assert.Len(t, sa.Labels, 2)
		assert.Equal(t, sa.Labels["a"], "b")
		assert.Equal(t, sa.Labels["c"], "d")

		assert.Len(t, sa.Annotations, 3)
		assert.Equal(t, sa.Annotations["a"], "b")
		assert.Equal(t, sa.Annotations["c"], "d")
		assert.Equal(t, sa.Annotations[LinkAnnotation], binding.Name)

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), storedSA))
		assert.Equal(t, sa.Name, storedSA.Name)
		assert.Equal(t, sa.Labels, storedSA.Labels)
		assert.Equal(t, sa.Annotations, storedSA.Annotations)
	})

	t.Run("no SA", func(t *testing.T) {
		cl := clBld().Build()
		h.Client = cl

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Managed: api.ManagedServiceAccountSpec{
						GenerateName: "sa",
						Labels: map[string]string{
							"a": "b",
							"c": "d",
						},
						Annotations: map[string]string{
							"a": "b",
							"c": "d",
						},
					},
				},
			},
		}

		h.Binding = binding

		sas, _, err := h.Sync(context.TODO())
		assert.NoError(t, err)

		assert.Len(t, sas, 1)
		sa := sas[0]
		assert.True(t, strings.HasPrefix(sa.Name, "sa"))
		assert.Len(t, sa.Labels, 3)
		assert.Equal(t, sa.Labels["a"], "b")
		assert.Equal(t, sa.Labels["c"], "d")
		assert.Equal(t, sa.Labels[ManagedByLabel], binding.Name)

		assert.Len(t, sa.Annotations, 3)
		assert.Equal(t, sa.Annotations["a"], "b")
		assert.Equal(t, sa.Annotations["c"], "d")
		assert.Equal(t, sa.Annotations[LinkAnnotation], binding.Name)

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), storedSA))
		assert.Equal(t, sa.Name, storedSA.Name)
		assert.Equal(t, sa.Labels, storedSA.Labels)
		assert.Equal(t, sa.Annotations, storedSA.Annotations)
	})

	t.Run("flip referenced to managed", func(t *testing.T) {
		cl := clBld().
			WithObjects(
				&corev1.ServiceAccount{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "sa",
						Namespace: "default",
					},
				},
			).
			Build()

		h.Client = cl

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Reference: corev1.LocalObjectReference{
						Name: "sa",
					},
				},
			},
		}

		_, _, err := h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.NotContains(t, ManagedByLabel, storedSA.Labels)
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Managed: api.ManagedServiceAccountSpec{
						Name: "sa",
					},
				},
			},
		}

		_, _, err = h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA = &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])
	})

	t.Run("flip managed to referenced", func(t *testing.T) {
		cl := clBld().Build()

		h.Client = cl

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Managed: api.ManagedServiceAccountSpec{
						Name: "sa",
					},
				},
			},
		}

		_, _, err := h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Reference: corev1.LocalObjectReference{
						Name: "sa",
					},
				},
			},
		}

		_, _, err = h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA = &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.NotContains(t, ManagedByLabel, storedSA.Labels)
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])
	})

	t.Run("disallow taking ownership", func(t *testing.T) {
		cl := clBld().Build()

		h.Client = cl

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Managed: api.ManagedServiceAccountSpec{
						Name: "sa",
					},
				},
			},
		}

		_, _, err := h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])

		binding.Name = "binding2"

		_, _, err = h.Sync(context.TODO())

		binding.Name = "binding"

		assert.Error(t, err)

		storedSA = &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])
	})

	t.Run("single owner, multiple referenced", func(t *testing.T) {
		cl := clBld().Build()

		h.Client = cl

		binding.Spec.Secret.LinkedTo = []api.SecretLink{
			{
				ServiceAccount: api.ServiceAccountLink{
					Managed: api.ManagedServiceAccountSpec{
						Name: "sa",
					},
				},
			},
		}

		_, _, err := h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding", storedSA.Annotations[LinkAnnotation])

		binding2 := &api.SPIAccessTokenBinding{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "binding2",
				Namespace: "default",
			},
			Spec: api.SPIAccessTokenBindingSpec{
				Secret: api.SecretSpec{
					LinkedTo: []api.SecretLink{
						{
							ServiceAccount: api.ServiceAccountLink{
								Reference: corev1.LocalObjectReference{
									Name: "sa",
								},
							},
						},
					},
				},
			},
		}

		binding3 := &api.SPIAccessTokenBinding{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "binding3",
				Namespace: "default",
			},
			Spec: api.SPIAccessTokenBindingSpec{
				Secret: api.SecretSpec{
					LinkedTo: []api.SecretLink{
						{
							ServiceAccount: api.ServiceAccountLink{
								Reference: corev1.LocalObjectReference{
									Name: "sa",
								},
							},
						},
					},
				},
			},
		}

		h.Binding = binding2

		_, _, err = h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA = &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding,binding2", storedSA.Annotations[LinkAnnotation])

		h.Binding = binding3

		_, _, err = h.Sync(context.TODO())
		assert.NoError(t, err)

		storedSA = &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKey{Name: "sa", Namespace: "default"}, storedSA))
		assert.Equal(t, "sa", storedSA.Name)
		assert.Equal(t, "binding", storedSA.Labels[ManagedByLabel])
		assert.Equal(t, "binding,binding2,binding3", storedSA.Annotations[LinkAnnotation])
	})
}

func TestLinkSecretToServiceAccount(t *testing.T) {
	scheme := runtime.NewScheme()
	assert.NoError(t, corev1.AddToScheme(scheme))

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "secret",
			Namespace: "default",
		},
	}

	sa := &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "sa",
			Namespace: "default",
		},
	}

	cl := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(secret, sa).
		Build()

	binding := &api.SPIAccessTokenBinding{
		Spec: api.SPIAccessTokenBindingSpec{
			Secret: api.SecretSpec{
				LinkedTo: []api.SecretLink{
					{
						ServiceAccount: api.ServiceAccountLink{
							Reference: corev1.LocalObjectReference{
								Name: "sa",
							},
						},
					},
				},
			},
		},
	}

	r := serviceAccountHandler{
		Client:  cl,
		Binding: binding,
	}

	t.Run("link as secret", func(t *testing.T) {
		binding.Spec.Secret.LinkedTo[0].ServiceAccount.As = ""
		r.LinkToSecret(context.TODO(), []*corev1.ServiceAccount{sa}, secret)

		assert.Len(t, sa.Secrets, 1)
		assert.Equal(t, sa.Secrets[0].Name, secret.Name)

		loadedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), loadedSA))

		assert.Len(t, loadedSA.Secrets, 1)
		assert.Equal(t, loadedSA.Secrets[0].Name, secret.Name)
	})

	t.Run("link as image pull secret", func(t *testing.T) {
		binding.Spec.Secret.LinkedTo[0].ServiceAccount.As = api.ServiceAccountLinkTypeImagePullSecret
		r.LinkToSecret(context.TODO(), []*corev1.ServiceAccount{sa}, secret)

		assert.Len(t, sa.ImagePullSecrets, 1)
		assert.Equal(t, sa.ImagePullSecrets[0].Name, secret.Name)

		loadedSA := &corev1.ServiceAccount{}
		assert.NoError(t, cl.Get(context.TODO(), client.ObjectKeyFromObject(sa), loadedSA))

		assert.Len(t, loadedSA.ImagePullSecrets, 1)
		assert.Equal(t, loadedSA.ImagePullSecrets[0].Name, secret.Name)
	})
}

func TestUnlinkSecretFromServiceAccount(t *testing.T) {
	scheme := runtime.NewScheme()
	assert.NoError(t, corev1.AddToScheme(scheme))

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "secret",
			Namespace: "default",
		},
	}

	sa := &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "sa",
			Namespace: "default",
		},
	}

	cl := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(secret, sa).
		Build()

	binding := &api.SPIAccessTokenBinding{
		Spec: api.SPIAccessTokenBindingSpec{
			Secret: api.SecretSpec{
				LinkedTo: []api.SecretLink{
					{
						ServiceAccount: api.ServiceAccountLink{
							Reference: corev1.LocalObjectReference{
								Name: "sa",
							},
						},
					},
				},
			},
		},
	}

	r := serviceAccountHandler{
		Client:  cl,
		Binding: binding,
	}

	t.Run("removes only referenced secrets", func(t *testing.T) {
		sa := &corev1.ServiceAccount{
			Secrets: []corev1.ObjectReference{
				{
					Name: "another",
				},
				{
					Name: "secret",
				},
			},
			ImagePullSecrets: []corev1.LocalObjectReference{
				{
					Name: "another",
				},
				{
					Name: "secret",
				},
			},
		}

		changed := r.Unlink(secret, sa)

		assert.True(t, changed)
		assert.Len(t, sa.Secrets, 1)
		assert.Len(t, sa.ImagePullSecrets, 1)

		assert.Equal(t, sa.Secrets[0].Name, "another")
		assert.Equal(t, sa.ImagePullSecrets[0].Name, "another")
	})

	t.Run("doesn't fail if not referenced", func(t *testing.T) {
		sa := &corev1.ServiceAccount{
			Secrets: []corev1.ObjectReference{
				{
					Name: "another",
				},
			},
			ImagePullSecrets: []corev1.LocalObjectReference{
				{
					Name: "another",
				},
			},
		}

		changed := r.Unlink(secret, sa)

		assert.False(t, changed)
		assert.Len(t, sa.Secrets, 1)
		assert.Len(t, sa.ImagePullSecrets, 1)

		assert.Equal(t, sa.Secrets[0].Name, "another")
		assert.Equal(t, sa.ImagePullSecrets[0].Name, "another")
	})

	t.Run("doesn't fail on empty", func(t *testing.T) {
		sa := &corev1.ServiceAccount{}

		changed := r.Unlink(secret, sa)

		assert.False(t, changed)
		assert.Len(t, sa.Secrets, 0)
		assert.Len(t, sa.ImagePullSecrets, 0)
	})
}
